<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STT Mic Test</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, sans-serif; background: #1a1a2e; color: #eee; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
  .container { max-width: 600px; width: 100%; padding: 2rem; }
  h1 { font-size: 1.4rem; margin-bottom: 1.5rem; color: #e94560; }
  .controls { display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; align-items: center; }
  select, button { padding: 0.5rem 1rem; border: 1px solid #333; border-radius: 6px; background: #16213e; color: #eee; font-size: 0.9rem; cursor: pointer; }
  button { background: #e94560; border-color: #e94560; font-weight: 600; }
  button:hover { background: #c73651; }
  button:disabled { opacity: 0.4; cursor: not-allowed; }
  button.stop { background: #555; border-color: #555; }
  #status { padding: 0.5rem 0; font-size: 0.85rem; color: #888; }
  #status.connected { color: #4ecca3; }
  #status.error { color: #e94560; }
  #status.recording { color: #f0a500; }
  #transcript { background: #16213e; border: 1px solid #333; border-radius: 8px; padding: 1rem; min-height: 200px; max-height: 400px; overflow-y: auto; font-size: 1rem; line-height: 1.6; white-space: pre-wrap; margin-top: 1rem; }
  .partial { color: #888; font-style: italic; }
  .final { color: #eee; }
  label { font-size: 0.85rem; color: #888; }
</style>
</head>
<body>
<div class="container">
  <h1>Local STT - Microphone Test</h1>
  <div class="controls">
    <label>Model:</label>
    <select id="model">
      <option value="faster-whisper">faster-whisper</option>
      <option value="moonshine">moonshine</option>
      <option value="sensevoice">sensevoice</option>
    </select>
    <select id="modelSize">
      <option value="base">base</option>
      <option value="tiny">tiny</option>
      <option value="small">small</option>
      <option value="medium">medium</option>
      <option value="large-v3">large-v3</option>
    </select>
    <select id="language">
      <option value="">Auto-detect</option>
      <option value="en" selected>English</option>
      <option value="id">Indonesian</option>
      <option value="zh">Chinese</option>
      <option value="ja">Japanese</option>
      <option value="ko">Korean</option>
      <option value="es">Spanish</option>
      <option value="fr">French</option>
      <option value="de">German</option>
      <option value="ru">Russian</option>
      <option value="ar">Arabic</option>
      <option value="pt">Portuguese</option>
      <option value="hi">Hindi</option>
    </select>
    <button id="startBtn" onclick="startRecording()">Start Recording</button>
    <button id="stopBtn" class="stop" onclick="stopRecording()" disabled>Stop</button>
  </div>
  <div id="status">Ready - click Start Recording</div>
  <div id="transcript"></div>
</div>

<script>
let ws = null;
let audioContext = null;
let mediaStream = null;
let processor = null;
const TARGET_SAMPLE_RATE = 16000;

function setStatus(text, cls) {
  const el = document.getElementById('status');
  el.textContent = text;
  el.className = cls || '';
}

async function startRecording() {
  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;

  try {
    setStatus('Requesting microphone access...', '');
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: TARGET_SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true } });

    audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
    const source = audioContext.createMediaStreamSource(mediaStream);

    // Use ScriptProcessorNode (widely supported) to get raw PCM
    const bufferSize = 4096;
    processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

    setStatus('Connecting to server...', '');
    ws = new WebSocket('ws://localhost:8000/ws/transcribe');

    ws.onopen = () => {
      const model = document.getElementById('model').value;
      const modelSize = document.getElementById('modelSize').value;
      const language = document.getElementById('language').value || null;
      ws.send(JSON.stringify({
        model: model,
        model_size: modelSize,
        sample_rate: audioContext.sampleRate,
        language: language
      }));
      setStatus('Waiting for model to load (first time may take a moment)...', 'connected');
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      const transcript = document.getElementById('transcript');

      if (data.type === 'ready') {
        setStatus('Recording - speak now!', 'recording');
        // Start sending audio
        source.connect(processor);
        processor.connect(audioContext.destination);
      } else if (data.type === 'transcription') {
        const lang = data.language ? ` [${data.language}]` : '';
        const line = document.createElement('span');
        line.className = data.is_partial ? 'partial' : 'final';
        line.textContent = data.text + lang + '\n';
        transcript.appendChild(line);
        transcript.scrollTop = transcript.scrollHeight;
      } else if (data.type === 'done') {
        setStatus('Done', 'connected');
        cleanup();
      } else if (data.type === 'error') {
        setStatus('Error: ' + data.message, 'error');
      }
    };

    ws.onerror = () => { setStatus('WebSocket error', 'error'); cleanup(); };
    ws.onclose = (e) => {
      if (document.getElementById('startBtn').disabled) {
        setStatus('Connection closed unexpectedly - check model/server logs', 'error');
        cleanup();
      }
    };

    processor.onaudioprocess = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const float32 = e.inputBuffer.getChannelData(0);
      // Convert float32 [-1,1] to int16 PCM
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        const s = Math.max(-1, Math.min(1, float32[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      ws.send(int16.buffer);
    };

  } catch (err) {
    setStatus('Error: ' + err.message, 'error');
    cleanup();
  }
}

function stopRecording() {
  // Stop sending audio immediately
  if (processor) { try { processor.disconnect(); } catch(e) {} processor = null; }
  if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
  if (audioContext) { audioContext.close(); audioContext = null; }

  if (ws && ws.readyState === WebSocket.OPEN) {
    setStatus('Finalizing...', 'connected');
    try { ws.send('END'); } catch(e) {}
    // Force close after 3s if server doesn't respond
    setTimeout(() => {
      if (ws) { try { ws.close(); } catch(e) {} ws = null; }
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      setStatus('Done (timeout)', '');
    }, 3000);
  } else {
    cleanup();
  }
}

function cleanup() {
  if (processor) { try { processor.disconnect(); } catch(e) {} processor = null; }
  if (audioContext) { try { audioContext.close(); } catch(e) {} audioContext = null; }
  if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
  if (ws) { try { ws.close(); } catch(e) {} ws = null; }
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
}
</script>
</body>
</html>
